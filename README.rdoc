==Babl is Another weBLog



=Introduction

==Who am I?
@joshrowley, current student @FlatironSchool, former IT guy

==What does this presentation cover?

OmniAuth

1.  What is OmniAuth?
    What does it do and why should we use it?

2.  Anatomy of OmniAuth
    How does it work?

3.  Implementing OmniAuth
    That's all fine and dandy, but how do I actually write the code?

==What does this presentation *not* cover?

1.  Other authentication libraries, and how they compare to OmniAuth
    There are a ton of authentication libraries available for Rails
    developers:
      *   [devise](https://github.com/plataformatec/devise "Devise")
      *   [authlogic](https://github.com/binarylogic/authlogic "Authlogic")
      *   [clearance](https://github.com/thoughtbot/clearance "Clearance")
      *   [sorcery](https://github.com/NoamB/sorcery "Sorcery")
      *   [restful-authentication](https://github.com/technoweenie/restful-authentication "Restful Authentication")


Deals with the common problem of authenticating users to your site.
Will be a high level overview of authentication (specifically OAuth2)
What can I use to integrate into my Rails application? => couple options, today: OmniAuth (abstracts away OAuth 2)
How do I get started with the most basic

==What does this presentation *not* cover?
Implementing permissions on your sites resources
Creating your own authentication user/pw in tandem with other providers? => Refer to Railscast



=The Problem

==BABL
  I have my own app, and there's something about it that makes it special.

  Usually, user authentication is not what makes your app special.

  Even though user authentication is not special, I still need it for my application to work.

  === What do I do?
    Create my own authentication from scratch?


      I'm reinventing the wheel (hasn't someone else figured this out)

      I may not do it correctly

      It's super critical that I get it right (don't want to get in trouble for exposing my user's private info)


    Use an existing gem?

      Devise...etc. (flesh out more examples)





=OmniAuth
==What exactly is it? / History



  Written by Michael (3/30/10, first commit, 10/1/10 release) Bleigh with support from his employer Intridea (dev shop) see talk: http://www.intridea.com/blog/2011/5/31/omniauth-from-the-ground-up talks about the design thoughts and principles

  Rack middleware library: sits between your Rails application and the web server
    For Rack apps, we're not limited to Rails applications (Sinatra viable)

    2 principles
      login with anything
      assume nothing

    Magic box image slide

  Why are there so many Ruby authentication frameworks?
    devise
    authlogic
    clearance
    sorcery
    restful-authentication

    They make assumptions!
      only need one User model
      signup and provide pw
      only email validates user
      only one authetication method

      *i don't want to customize much*
        structured (i'm building my app around my authentication library)

      There's *ONE WAY* to authenticate with *ANY* provider
      results are the same

          OmniAuth blackbox
            login => provider => callback hash with standard info

          one interface for multiple providers

          accomplished throught the strategy abstraction

          not sure what happens
          different providers may be different logic (oauth, oauth2, openid, custom auth system)

          ALL I CARE ABOUT is the callback hash I get back

          IMG: slide from his presentation on the magic

          why is this abstraction good? What's the one thing I care about "user info"?
            don't care how we get it!!!



==Anatomy of OmniAuth: How does it do this?


  Back to slide of magic box

    OmniAuth is middleware

      Every provider is represented through a strategy
        What is a strategy? Just a class that inherits some stuff from the OmniAuth library

      Every strategy has two main behaviors/phases that are defined in the Class

        request phase

        call back phase


  Back to slide of magic box

    point out => need auth => request phase, in my application I specify "Hey, a user needs to authenticate with a :provider"

    In the view, there's a link_to provider => /auth/:provider
      ex: /auth/facebook, /auth/twitter
      these routes are picked up on by the OmniAuth middleware


    point out => Magic Box => strategy 

      each strategy is a class inheriting somes stuff from top level OmniAuth module


        def request_phase do
          ...
        end

        def callback_url do
          ...
        end

        OR

        def auth_hash do
          ...
        end



  
  Keeps eye out for this path: /auth/:provider (set in a config file)
  When it picks up on a route that it's configured for it uses a "strategy" to abstract away the authentication process with the provider
  OmniAuth is a black box, you supply app id and secret, OmniAuth figures out the transaction and returns you a nice hash with all the users info
  Has provider send back hash to a callback route in your app, for OmniAuth it's /auth/:provider/callback
    You'll need to have this is your routes.rb

  TODO: flow chart of OmniAuth request



==Implement OmniAuth!!!


Part 1: Getting the authentication hash.

*Step 0:* Setup your application with the provider

In the case of this Facebook example, I'm going to want to go to Facebook's Developer page, register my application, and grab the 


*Step 1:* Add the provider's gem to your Gemfile

    gem 'omniauth'
    gem 'omniauth-facebook'



*Step 2:* Run bundle install to load OmniAuth into your application environment

    $ bundle install


*Step 3:* Create initializer, so that OmniAuth middleware starts up with your app.

    $ touch config/initializers/omniauth.rb

omniauth.rb

    Rails.application.config.middleware.use OmniAuth::Builder do
      
      provider :facebook, 'APP_ID', 'APP_SECRET'

      provider :twitter, 'CONSUMER_KEY', 'CONSUMER_SECRET'
      provider :linked_in, 'CONSUMER_KEY', 'CONSUMER_SECRET'

    end

So now we can see that OmniAuth should be running as middleware

    $ rails server

Now, check out localhost:3000/auth/facebook

OmniAuth will do its magic based on the strategy given by the provider you specify.

DEMO: Open up browser and show that the callback routes is missing.

So OmniAuth did the request phase, redirected to Facebook's auth system. Once user enters correct password, Facebook tells OmniAuth the user is successfully authenticated and gives back user info in the format specific to FB's authentication method. OmniAuth is then going to go into the "callback" phase in order to return a hash with the info as an environment variable in the HTTP request.s

OmniAuth will then make a GET request with this hash information to the /auth/:provider/callback route of the application.

That's why right now it's giving a Missing Routes error. We need to define some kind of route and a controller that's going to handle the incoming request.

Generally, this is done using a SessionsController, with a route pointing to 'sessions#create'. The SessionsController will then have a create method, that we'll be able to take the hash find a User in our application and generate a 'logged_in' session.

First, routes.rb

*Step 4*: Create the route that will respond to the callback message.

    match '/auth/:provider/callback, :to => 'sessions#create'


Great, so I've made the route. What do I need to do next...

Define the Session create method in my Controller.


So I'm going to generate a sessions controller.

    $ rails g controller sessions


*Step 5* Now to define the sessions#create method:

in /app/controllers/sessions_controller.rb

class SessionsController < ApplicationController
  def create
    render :text => request.env['omniauth.auth'].inspect
  end
end


    '#<OmniAuth::AuthHash 
        credentials=
          #<Hashie::Mash
            expires=true
            expires_at=1357774112
            token="AAAEV4AIlNYYBAE4MCGRj4RZAL1gWRboJqwXeYNZAqThDZA51fv3vIZCXIgIDz19vlalG7zyOBLfL0u2y8ZB6kiUJvF5vCE3wZD">
      
        extra=#<Hashie::Mash
          raw_info=
            #<Hashie::Mash
                email="joshua.rowley@nyu.edu"
                first_name="Josh"
                gender="male"
                id="837810"
                last_name="Rowley"
                link="http://www.facebook.com/joshuarowley"
                locale="en_US"
                name="Josh Rowley"
                timezone=-5
                updated_time="2012-10-12T02:49:25+0000"
                username="joshuarowley"
                verified=true
              >
          >
        
        info=
          #<OmniAuth::AuthHash::InfoHash
            email="joshua.rowley@nyu.edu"
            first_name="Josh"
            image="http://graph.facebookcom/837810/picture?type=square" last_name="Rowley"
            name="Josh Rowley"
            nickname="joshuarowley"
            urls=
              #<Hashie::Mash
                Facebook="http://www.facebook.com/joshuarowley"
                >
            verified=true
            >


        provider="facebook"

        uid="837810">'




So, we can compare this with our spec of what the returned hash should look like.

**show slide with anatomy of a hash



GREAT!



part 2: Casting that hash into my application based on my needs


Now we as developers have the hash, time to decide what to do with it.
We're going to want to persist data about newly authenticated users, because they we will now have blog posts that need can be associated with users.

Thus, a User model was born!

What do I want this User model to store. Well, what's great about OmniAuth is that I don't need to worry about whether some of my providers return a different type of object that the others. I always know that my hash is going to have the following information





SHOW Bare Minimum


SLIDE: attributes of the User

auth.provider #=> identifies the auth service
auth.uid #-> unique id for user on auth servcie
auth.info.name #=> a name for the user

User schema

id    name    provider    uid  



Wait a second though, this model schema is going to cause issues for us.

Things get dicey once you want to allow users to authenticate using multiple providers, and not just one.

You'll soon have a non-normalized database where the same person appears in the users table multiple times because they have multiple authorizations.

So, what should we do, break out the authorizations into its own Model.

*Step 6:*

    $ rails g model User name:string email:string

    $ rails g model Authorization provider:string uid:string user_id:integer

uid is string b/c what if uid has letters? leave it flexible. Keep OmniAuth flexible.


*Step 7:* Migrate DB

    $ rake db:migrate


*Step 8:* Add associations between User and Model

So now, User has_many :authorizations

and Authorization belongs_to :user

So I'll put in my in models

user.rb
  
    class User << ActiveRecord::Base
      has_many :authorizations
    end

authorization.rb

    class Authorization
      belongs_to :user
    end


*Step 9: Validate authorization's atrributes presence and uniqueness.


I'm also going to throw some validations on here, so that authorizations must be created with an associated user, an external unique ID, and which provider it's associated with, as well as validate the uniqueness of the uid in the scope/context of their providers (with multiple providers, we have to ensure that two providers can have the same uid for two entries)


authorization.rb

    class Authorization
      ...

      validates_presence_of :user_id, :uid, :provider
      validates_uniqueness_of :uid, :scope => :provider

    end



*Step 10: Code sessions#create logic to do something meaningful

What should the sessions#create do:

  1. When a user signs in, look for existing Authorizations for
  that external account.  
  2. Create a user if no authorization is found.
  3. Add an authorization to an existing user if the user is already logged in.

Make this a slide::Highlight undefined methods

def create
  auth = request.env['omniauth.auth']

  unless @auth = Authorization.find_from_hash(auth)
    @auth = Authorization.create_from_hash(auth, current_user)
  end

  self.current_user = @auth.user

  render :text => "Welcome, #{current_user.name}."
end

    def create

      auth_hash = request.env['omniauth.auth']

      @authorization = Authorization.find_by_provider_and_uid(auth_hash.provider, auth_hash.uid)

      if @authorization
        render :text => "Welcome back #{@authorization.user.name}! You're logged in through #{@authorization.provider}."
      else
        user = User.new(:name => auth_hash.info.name, :email => auth_hash.info.email)
        user.authorizations.build(:provider => auth_hash.provider, :uid => auth_hash.uid)
        user.save
        render :text => "Hi #{user.name}! Your account has been signed up."
      end
    end


Challenge: Can you write a strategy?






