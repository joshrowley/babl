3-


=0.0 Introduction

===Who am I?
@joshrowley, current student @FlatironSchool, former IT guy

===What does this presentation cover?

OmniAuth

1.  What is OmniAuth?
    What does it do and why should we use it?

2.  Anatomy of OmniAuth
    How does it work?

3.  Implementing OmniAuth
    That's all fine and dandy, but how do I actually write the code?

    #TODO: split out this third step into different parts so that
    there are natural stopping points based on how far we get in the
    implementation and how much time we have.

===What does this presentation not cover?

This presentation is meant as an introduction to OmniAuth and a quick start
way to learn about how it can help you as a developer. Thus, I will covering
the minimum basic concepts in order to authenticate a user. I will not be
covering the following:

1.  Other authentication libraries, and how they compare to OmniAuth  
    There are a ton of authentication libraries available for Rails
    developers. I don't really know enough about them to judge whether
    these might be better solution for you:

      #TODO: figure out better markdown syntax for nested list

      [devise](https://github.com/plataformatec/devise "Devise")
      [authlogic](https://github.com/binarylogic/authlogic "Authlogic")
      [clearance](https://github.com/thoughtbot/clearance "Clearance")
      [sorcery](https://github.com/NoamB/sorcery "Sorcery")
      [restful-authentication](https://github.com/technoweenie/restful-authentication "Restful Authentication")

2.  Implementing user permissions for your resources 
    I'm going to show how to get a user authenticated in your, but you'll
    need to figure out how you'll implement permissions for your app's
    resources. Here are some resources that will help you if that's the
    step your on.:

    # TODO: Add some resources

3.  Low level examination of how OmniAuth works
    We'll take a brief look at the overarching design of OmniAuth, but I
    won't go into specific implementation and methods of the OmniAuth
    module.






=1.0 What is OmniAuth? Why should we use it?


==1.1 The Authentication Problem

An example

BABL is a blogging platform in development. It's going to reinvent
what blogs can do. The dev team hasn't gotten far at all. So, far
there's only a Post model and each post has a title and some content.

from db/schema.rb:

    create_table "posts", :force => true do |t|
      t.string   "title"
      t.text     "content"
      t.datetime "created_at", :null => false
      t.datetime "updated_at", :null => false
    end



Trust me, there's some innovation coming down the pipeline. The BABL
dev team's main focus is on the Post model, that's the core of their
product.

But pretty soon, they'll need to implement some type of user authentication
system. After all, we can't have anyone have access to creating, updating,
and destroying posts.


It's crunch time, the BABL dev team needs to showcase their product to
potential investors. They still have a ton of work to do on special Post
related features, but they won't have any type of usable product to
show if there's no user login! What are their options?



== 1.2 Options for adding authentication

===1.2.1 Create authentication from scratch

The team could try writing their own authentication system.

This seems like reinventing the wheel though right?. I mean
what web application doesn't have user logins. Surely someone
has figured out a pretty damn good way of doing it.

There's also the possibility that they don't implement it correctly.
There would need to be extensive testing throughout all layers of
the application to find any security holes.

This will also take a long time and demo day is soon!



===1.2.2 Use existing authentication libraries

Devise, Authlogic, Clearance, Sorcery, Restful Authentication

You can create your own application's authentication system using
open source gems like these.

But, maybe I don't want to have my users have to remember another
set of logins and passwords.

Furthermore, the team is really pressed for time, these authentciation
libraries may have rigid requirements, or make rigid assumptions
about how our application needs to architected.

The BABL developers need to get it working ASAP, while maintaining
flexibility for the future, when perhaps they'll add their own
authentication. That leads them to...


1.2.3 OmniAuth


Written by Michael  Bleigh with support from his employer Intridea (dev shop) 
(3/30/10, first commit, 10/1/10 release)
see talk: http://www.intridea.com/blog/2011/5/31/omniauth-from-the-ground-up talks about the design thoughts and principles


OmniAuth provides an easy abstract interface with authentication
providers.

OmniAuth is flexible and tries to make as little assumptions as
possible. It's built to be able to authenticate with any external
or internal authentication system, all you need to do is write
a strategy.

#TODO: Create slide of all the available provider strategies.

The implementation of external provider doesn't matter as long
as you have a strategy.

#TODO: add examples of different auth systems

OmniAuth standardizes the way you request
authorization in your application as well as send back your
application a cleaned up hash with all your user's info.

# SLIDE: show magic diagram => THIS is why we should use OmniAuth
# SLIDE: show basic required hash

Omniauth gives us an easy way to authenticate users TODAY, while
leaving a ton of flexibility to allow our application to authenticate
with whatever the future may hold.










=2.0: Anatomy of OmniAuth: How does this work?

SLIDE: Magic Box

So this diagram is easy to follow. My application triggers
something (a user clicking on login) that will indicate
to OmniAuth that I'm requesting authentication.

Something happens, and then I get back an authentication hash
back indicating that the external provider confirmed this persons
identity. With this user info that I now can do whatever I want
with in my application.

But, at least for me this diagram is a little too abstract, so before
we actually get into the actual implementation on how to integrate
OmniAuth into our application, let's take a peek at the "magic".


SLIDE: Facts about Omniauth



===2.1: OmniAuth is middleware

OmniAuth is Rack middleware that can be used with any Rack based
Ruby applications.

It's not just limited to Rails, you could use it in a Sinatra
application as well like this:

    require 'sinatra'
    require 'omniauth'

    class MyApplication < Sinatra::Base
      use Rack::Session::Cookie
      use OmniAuth::Strategies::Developer
    end

In a Rails application, you would add `config/initializers/omniauth.rb`

`omniauth.rb`

    Rails.application.config.middleware.use OmniAuth::Builder do
      provider :twitter, ENV['TWITTER_KEY'], ENV['TWITTER_SECRET']
      provider :facebook, YOUR_APP_ID, YOUR_APP_SECRET
    end


This tells Rails to use OmniAuth as middleware for facebook and twitter
when the application boots. We'll go into this in more detail in the
implementation.




===2.2: Omniauth knows how to authenticate through "strategies"

We'll take a look at the code a strategy entails in a little
bit.

SLIDE: providers again!

What is a strategy? A bunch of Ruby code!

Specifically, a strategy is class that inherits a bunch of
magical stuff from an OmniAuth::Strategies module.


Interaction with the strategy class can be defined into
two phases: the request phase, and the callback phase



===2.3 The Request Phase

The Request phase is triggered when your applications tells
OmniAuth that it needs authentication.

How do you tell OmniAuth this?

The OmniAuth middleware listens for HTTP requests going to
the path `/auth/:provider` where `:provider` refers to the
specific provider strategy contained in `omniauth.rb`.

When OmniAuth receives the HTTP request from your web server
(e.g. nginx, Apache), it starts the request phase.

What is the request phase?

The first part of the strategy. All the necessary steps to
authenticate with the external provider.

As a developer, I don't know any of the details of how the strategy
does this, I trust that it works.

OmniAuth acts like a wrapper, sending whatever necessary information
in the right format to the right provider.

In OAuth, this is a redirect to the provider's auth interface (facebook)
OpenID, LDAP, something else, the logic is different, but the abstract
concept of what OmniAuth is doing is the same. It's communicating with
the external provider's authentication API, whatever it may be.

The external provider then processes the authentication request (e.g.
Facebook login), and sends back to OmniAuth whatever info it needs
to indicate that the user passed or failed authentication. OmniAuth then
triggers the callback phase.


===2.4 The Callback Phase

OmniAuth receives the raw response from Facebook's authentication system
and then uses the strategy again to figure how to parse and format the
response into the standard authentication hash that our application is
expecting.

OmniAuth will then set that authentication hash in the Rack environment
and send a request to a `/auth/:provider/callback` route. Again, this
hash will always contain the keys `provider`, `uid`, `info`, and
`info['name']. Every strategy must return this hash and because of this
we can easily add multiple providers since our application knows what
to expect no matter what strategy we use.

===2.5 Your application's logic

Great! Now this authentication hash has a way into your application, and
you can feel free to do what you want with it.

But, most likely, you'll want to add a SessionsController that the callback
phrase routes to that will find or create the User in your application.

Everytime a user logs in with the same credentials through a provider, the
provider should return an authentication hash with the same `uid`, so
each time the user comes back it should find the same user, and associated
permissions specific to your application.


===2.6 Peeking at some strategies

Let's take a quick look at some of the available strategies, and we can
see that there are methods defined in the provider's class that link up
with the two phases (request/callback).


For example, in the Facebook strategy:

https://github.com/mkdynamic/omniauth-facebook/blob/master/lib/omniauth/strategies/facebook.rb

    module OmniAuth
      module Strategies
        class Facebook < OmniAuth::Strategies::OAuth2

        ...

        def request_phase

          ...

        end




Example from GitHub

    module OmniAuth
      module Strategies
        class GitHub < OmniAuth::Strategies::OAuth2
          ...

          def request_phase
            super
          end
    ...




=3.0: Implement OmniAuth!!!


==3.1: Getting the authentication hash from Facebook.



===3.1.0: Setup your application with the provider

In the case of this Facebook example, I'm going to want to go to Facebook's Developer page, register my application, and grab the 


===3.1.1: Add the provider's gem to your Gemfile

    gem 'omniauth'
    gem 'omniauth-facebook'



===3.1.2: Run bundle install to load OmniAuth into your application environment

    $ bundle install


===3.1.3: Create omniauth config file, so that OmniAuth middleware starts up
with your app.

    $ touch config/initializers/omniauth.rb

omniauth.rb

    Rails.application.config.middleware.use OmniAuth::Builder do
      provider :facebook, 'APP_ID', 'APP_SECRET'
      provider :twitter, 'CONSUMER_KEY', 'CONSUMER_SECRET'
      provider :linked_in, 'CONSUMER_KEY', 'CONSUMER_SECRET'
    end

===3.1.4: Verify that OmniAuth middleware is running

So now we can see that OmniAuth should be running as middleware

    $ rails server

Now, check out localhost:3000/auth/facebook

OmniAuth will do its magic based on the strategy given by the provider you specify.

So OmniAuth did who, redirected to Facebook's auth system.
Once the user entered correct password, Facebook tells OmniAuth the user is successfully
authenticated and gives back user info in the format specific to FB's authentication
method. OmniAuth is then going to go into the "callback" phase in order to transform
what Facebook gave it back into a hash with the info as a Rack environment variable in
a HTTP request to `/auth/:provider/callback

What error do we expect?

Missing routes!

We need to define a route and a controller that's going to handle the incoming request
with authentication hash from OmniAuth.

Generally, this is done using a SessionsController, with a route pointing to
'sessions#create'. In that create method, we should have logic in our application
that should either find a User of our application if that person has already
authenticated before, or create a new user.


===3.1.5 Create the route that will respond to the callback message.

`routes.rb`

    match '/auth/:provider/callback, :to => 'sessions#create'


Great, so I've made the route. What do I need to do next?

Create a controller method that responds to that route.



===3.1.6 Create a sessions controller


So I'm going to generate a sessions controller.

    $ rails g controller sessions

And then, write the create method:


===3.1.7 Now to define the sessions#create method:

I'm just going to write something very simple for now, just to show
that we are in fact now authenticating with Facebook.

I'll just render the request incoming from Rack:

in `/app/controllers/sessions_controller.rb`

    class SessionsController < ApplicationController
      def create
        render :text => request.env['omniauth.auth'].inspect
      end
    end


And, now if we go to the browser and go to `/auth/facebook`, the
returned page should have the authentication hash in the source.


#TODO: move this into a slide
    '#<OmniAuth::AuthHash 
        credentials=
          #<Hashie::Mash
            expires=true
            expires_at=1357774112
            token="AAAEV4AIlNYYBAE4MCGRj4RZAL1gWRboJqwXeYNZAqThDZA51fv3vIZCXIgIDz19vlalG7zyOBLfL0u2y8ZB6kiUJvF5vCE3wZD">
      
        extra=#<Hashie::Mash
          raw_info=
            #<Hashie::Mash
                email="joshua.rowley@nyu.edu"
                first_name="Josh"
                gender="male"
                id="837810"
                last_name="Rowley"
                link="http://www.facebook.com/joshuarowley"
                locale="en_US"
                name="Josh Rowley"
                timezone=-5
                updated_time="2012-10-12T02:49:25+0000"
                username="joshuarowley"
                verified=true
              >
          >
        
        info=
          #<OmniAuth::AuthHash::InfoHash
            email="joshua.rowley@nyu.edu"
            first_name="Josh"
            image="http://graph.facebookcom/837810/picture?type=square" last_name="Rowley"
            name="Josh Rowley"
            nickname="joshuarowley"
            urls=
              #<Hashie::Mash
                Facebook="http://www.facebook.com/joshuarowley"
                >
            verified=true
            >


        provider="facebook"

        uid="837810">'




So, we can compare this with our spec of what the returned hash should look like.

**show slide with anatomy of a hash



GREAT!



==3.2: Using that hash in our application


Now we as developers have the hash, time to decide what to do with it.
We're going to want to persist data about newly authenticated users, because they will now have blog posts that need can be associated with users.

Thus, a User model is born!

What do I want this User model to store. Well, what's great about OmniAuth is that I don't need to worry about whether some of my providers return a different type of object that the others. I always know that my hash is going to have the following information


SHOW Bare Minimum

SLIDE: attributes of the User

auth.provider #=> identifies the auth service
auth.uid #-> unique id for user on auth servcie
auth.info.name #=> a name for the user


The `uid` is going to be the unique identifier for that user in the context
of the external provider, so that should be a column in our User model, so that
when the user logs in again, it should pull up the same user.


User schema

id    name    provider    uid  



Wait a second though, this model schema is going to cause issues for us.

Can anyone predict the problem we're going to have? How is this going to
affect us in the future?

Things get dicey once you want to allow users to authenticate using multiple
providers, and not just one. When the same person authenticates with a different
provider, another User entry will be created, and what we want is for the multiple
authentications to point to the same user record and thus will have the correct
associations with other resources in our application.

The database is not normalized in this way, so we'll want to break out authorizations
into its own model, where User `has_many :authorizations` and Authorization
`belongs_to :authorization`.

So, let's build those models:

===3.2.1 Build User and Authorization models

    $ rails g model User name:string email:string
    $ rails g model Authorization provider:string uid:string user_id:integer


===3.2.2 Migrate the database

    $ rake db:migrate

===3.2.3 Add the association between User and Authorization

user.rb
  
    class User << ActiveRecord::Base
      has_many :authorizations
    end

authorization.rb

    class Authorization
      belongs_to :user
    end


===3.2.4: Validate authorization's atrributes presence and uniqueness.


I'm also going to throw some validations on here, so that authorizations must be
created with an associated user, an external unique ID, and which provider it's
associated with, as well as validate the uniqueness of the uid in the scope/context
of their providers (with multiple providers, we have to ensure that two providers
can have the same uid for two entries).


authorization.rb

    class Authorization
      ...

      validates_presence_of :user_id, :uid, :provider
      validates_uniqueness_of :uid, :scope => :provider

    end

===3.2.5: Validate uniqueness of email


I'll also validate the uniqueness of the `:email` attribuet of my User model, to
make sure that I don't have multiple records associated to the same person.

user.rb

    class User
      ...

      validates_uniqueness_of :email
    end



===3.2.6: Write 1st iteration of sessions create logic


#TODO: Make a slide
What should the sessions#create do:

  1. When a user signs in, look for existing Authorizations for
  that external account.  
  2. Create a user if no authorization is found.
  3. Add an authorization to an existing user if the user is already logged in.


So, let me clear my db real quick just to show you this logic is working.

Now, when a user authenticates for the first time, it should create a user.

When the same user comes to authenticate, since I already have their authorization
information in the database, it should execute the `else` block.


===3.2.7: Creating a session with a method in the Application Controller

We want the user to stay logged in throughout the entire application.

We'll put whether or not the user is logged in into the Application Controller,
whose methods are inherited by every controller in our application.

Now, how do I persist a user's presence with every later request they enter?

We'll use the sessions 



===3.2.8: Creating the login link

===3.2.9: Creating a logout


==3.3 The world is your oyster!

==Refactor the code:

1. Push the logic out of the controller and down to the models.

2. Cache the current user in an application wide instance variable.




























Make this a slide::Highlight undefined methods

def create
  auth = request.env['omniauth.auth']

  unless @auth = Authorization.find_from_hash(auth)
    @auth = Authorization.create_from_hash(auth, current_user)
  end

  self.current_user = @auth.user

  render :text => "Welcome, #{current_user.name}."
end

    def create

      auth_hash = request.env['omniauth.auth']

      @authorization = Authorization.find_by_provider_and_uid(auth_hash.provider, auth_hash.uid)

      if @authorization
        render :text => "Welcome back #{@authorization.user.name}! You're logged in through #{@authorization.provider}."
      else
        user = User.new(:name => auth_hash.info.name, :email => auth_hash.info.email)
        user.authorizations.build(:provider => auth_hash.provider, :uid => auth_hash.uid)
        user.save
        render :text => "Hi #{user.name}! Your account has been signed up."
      end
    end


Challenge: Can you write a strategy?






